---
title: "Compute Emissions Dashboard"
freeze: false
---

## Purpose

This page summarizes tracked compute emissions for epi-ML runs and modules.

```{=html}
<style>
#run-summary table,
#modules-summary table,
#reduction-recommendations table {
  font-size: 0.82rem;
}

#run-summary table th,
#run-summary table td,
#modules-summary table th,
#modules-summary table td,
#reduction-recommendations table th,
#reduction-recommendations table td {
  padding: 0.2rem 0.35rem;
}
</style>
```

```{r}
#| echo: false
read_csv_safe <- function(path) {
  if (!file.exists(path)) return(data.frame())
  tryCatch(read.csv(path, stringsAsFactors = FALSE), error = function(e) data.frame())
}

first_non_empty <- function(x, fallback = "") {
  y <- as.character(x)
  y <- y[!is.na(y) & nzchar(trimws(y))]
  if (length(y) == 0) return(fallback)
  y[[1]]
}

normalize_source <- function(x) {
  src <- tolower(trimws(as.character(x)))
  src[!(src %in% c("local", "cloud"))] <- NA_character_
  src
}

build_module_summary_from_events <- function(events_df) {
  if (nrow(events_df) == 0) return(data.frame())

  module_totals <- aggregate(
    events_df[, c("duration_seconds", "emissions_kg", "energy_kwh"), drop = FALSE],
    by = list(module = events_df$module),
    FUN = sum
  )
  module_exec <- aggregate(events_df$run_id, by = list(module = events_df$module), FUN = length)
  names(module_exec)[2] <- "executions"
  module_runs <- aggregate(events_df$run_id, by = list(module = events_df$module), FUN = function(x) length(unique(x)))
  names(module_runs)[2] <- "run_count"
  module_failed <- aggregate(
    events_df$status,
    by = list(module = events_df$module),
    FUN = function(x) sum(!is.na(x) & x != "ok")
  )
  names(module_failed)[2] <- "failed_executions"
  module_mean <- aggregate(events_df$emissions_kg, by = list(module = events_df$module), FUN = mean)
  names(module_mean)[2] <- "mean_emissions_kg"
  module_median <- aggregate(events_df$emissions_kg, by = list(module = events_df$module), FUN = median)
  names(module_median)[2] <- "median_emissions_kg"
  module_label <- aggregate(
    events_df$module_label,
    by = list(module = events_df$module),
    FUN = function(x) first_non_empty(x, "Unknown")
  )
  names(module_label)[2] <- "module_label"
  module_href <- aggregate(
    events_df$page_href,
    by = list(module = events_df$module),
    FUN = function(x) first_non_empty(x, "code/index.html")
  )
  names(module_href)[2] <- "page_href"

  modules_df <- Reduce(
    function(x, y) merge(x, y, by = "module", all = TRUE),
    list(module_totals, module_exec, module_runs, module_failed, module_mean, module_median, module_label, module_href)
  )

  names(modules_df)[names(modules_df) == "duration_seconds"] <- "total_duration_seconds"
  names(modules_df)[names(modules_df) == "emissions_kg"] <- "total_emissions_kg"
  names(modules_df)[names(modules_df) == "energy_kwh"] <- "total_energy_kwh"

  modules_df$total_emissions_kg[is.na(modules_df$total_emissions_kg)] <- 0
  total_emissions <- sum(modules_df$total_emissions_kg, na.rm = TRUE)
  modules_df$emissions_share_pct <- if (total_emissions > 0) {
    100 * modules_df$total_emissions_kg / total_emissions
  } else {
    0
  }
  modules_df$emissions_rate_kg_per_hour <- ifelse(
    modules_df$total_duration_seconds > 0,
    modules_df$total_emissions_kg / (modules_df$total_duration_seconds / 3600),
    0
  )
  modules_df$avg_duration_seconds <- ifelse(
    modules_df$executions > 0,
    modules_df$total_duration_seconds / modules_df$executions,
    0
  )
  modules_df$avg_energy_kwh <- ifelse(
    modules_df$executions > 0,
    modules_df$total_energy_kwh / modules_df$executions,
    0
  )
  modules_df[order(modules_df$total_emissions_kg, decreasing = TRUE), , drop = FALSE]
}

build_recommendations <- function(modules_df, runs_df) {
  if (nrow(modules_df) == 0 || nrow(runs_df) == 0) return(data.frame())

  out <- data.frame(
    priority = integer(),
    recommendation = character(),
    rationale = character(),
    stringsAsFactors = FALSE
  )

  top_idx <- which.max(modules_df$total_emissions_kg)
  top_module <- modules_df[top_idx, , drop = FALSE]
  top_module_name <- top_module$module_label[[1]]
  out <- rbind(
    out,
    data.frame(
      priority = 1L,
      recommendation = paste0("Prioritize optimization and caching for ", top_module_name, "."),
      rationale = sprintf("This module contributes %.1f%% of tracked emissions.", top_module$emissions_share_pct[[1]]),
      stringsAsFactors = FALSE
    )
  )

  out <- rbind(
    out,
    data.frame(
      priority = 2L,
      recommendation = "Run only modules with changed inputs during development.",
      rationale = "Selective reruns reduce avoidable compute time and electricity use.",
      stringsAsFactors = FALSE
    )
  )

  longest <- runs_df[which.max(runs_df$total_duration_seconds), , drop = FALSE]
  if (is.finite(longest$total_duration_seconds[[1]]) && longest$total_duration_seconds[[1]] > 1800) {
    out <- rbind(
      out,
      data.frame(
        priority = 3L,
        recommendation = "Schedule long runs during lower-carbon grid periods when possible.",
        rationale = sprintf(
          "Longest cloud run duration was %.1f minutes; moving heavy jobs can lower emissions intensity.",
          longest$total_duration_seconds[[1]] / 60
        ),
        stringsAsFactors = FALSE
      )
    )
  } else {
    out <- rbind(
      out,
      data.frame(
        priority = 3L,
        recommendation = "Use energy-efficient hardware for repeated experiment sweeps.",
        rationale = "Hardware efficiency directly lowers kWh and emissions for equivalent workloads.",
        stringsAsFactors = FALSE
      )
    )
  }

  out[order(out$priority), , drop = FALSE]
}

events_path <- file.path("data", "public", "outputs", "emissions", "emissions_module_events.csv")
runs_path <- file.path("data", "public", "outputs", "emissions", "emissions_run_summary.csv")

events <- read_csv_safe(events_path)
runs <- read_csv_safe(runs_path)
modules <- data.frame()
recommendations <- data.frame()

has_data <- nrow(events) > 0 && nrow(runs) > 0
if (has_data) {
  events$timestamp_utc <- as.POSIXct(events$timestamp_utc, format = "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
  runs$start_time_utc <- as.POSIXct(runs$start_time_utc, format = "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
  runs$end_time_utc <- as.POSIXct(runs$end_time_utc, format = "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
  if (!"run_source" %in% names(events)) events$run_source <- NA_character_
  if (!"run_source" %in% names(runs)) runs$run_source <- NA_character_
  events$run_source <- normalize_source(events$run_source)
  runs$run_source <- normalize_source(runs$run_source)
  if (any(is.na(events$run_source)) && any(!is.na(runs$run_source))) {
    src_map <- setNames(runs$run_source, runs$run_id)
    mapped <- src_map[events$run_id]
    missing_idx <- is.na(events$run_source) & !is.na(mapped)
    events$run_source[missing_idx] <- mapped[missing_idx]
  }
  events$run_source[is.na(events$run_source)] <- "local"
  if (any(is.na(runs$run_source))) {
    run_src <- tapply(events$run_source, events$run_id, function(v) if (any(v == "cloud")) "cloud" else "local")
    mapped <- run_src[runs$run_id]
    missing_idx <- is.na(runs$run_source) & !is.na(mapped)
    runs$run_source[missing_idx] <- mapped[missing_idx]
  }
  runs$run_source[is.na(runs$run_source)] <- "local"

  if (nrow(events) > 0) {
    num_cols <- c("duration_seconds", "elapsed_minutes_run", "emissions_kg", "energy_kwh")
    for (nm in intersect(num_cols, names(events))) {
      events[[nm]] <- suppressWarnings(as.numeric(events[[nm]]))
    }
    runs$total_duration_seconds <- suppressWarnings(as.numeric(runs$total_duration_seconds))
    runs$total_energy_kwh <- suppressWarnings(as.numeric(runs$total_energy_kwh))
    runs$total_emissions_kg <- suppressWarnings(as.numeric(runs$total_emissions_kg))
    runs$avg_emissions_rate_kg_per_hour <- suppressWarnings(as.numeric(runs$avg_emissions_rate_kg_per_hour))
    events <- events[order(events$run_id, events$elapsed_minutes_run), , drop = FALSE]
    modules <- build_module_summary_from_events(events)
    recommendations <- build_recommendations(modules, runs)
  }

  has_data <- nrow(events) > 0 && nrow(modules) > 0 && nrow(runs) > 0
}
```

```{r}
#| echo: false
#| results: asis
if (!has_data) {
  cat(
    "No emissions data is available yet.\n\n",
    "Run local module tracking or the GitHub Actions deploy workflow with emissions tracking, then refresh this page.",
    sep = ""
  )
} else {
  total_emissions_kg <- sum(events$emissions_kg, na.rm = TRUE)
  total_energy_kwh <- sum(events$energy_kwh, na.rm = TRUE)
  total_hours <- sum(events$duration_seconds, na.rm = TRUE) / 3600
  total_runs <- length(unique(events$run_id))
  total_modules <- length(unique(events$module))
  total_exec <- nrow(events)
  mean_module_emissions_g <- mean(events$emissions_kg, na.rm = TRUE) * 1000

  cat(sprintf("<strong>Tracked runs:</strong> %d<br/>", total_runs))
  cat(sprintf("<strong>Total modules:</strong> %d<br/>", total_modules))
  cat(sprintf("<strong>Module executions:</strong> %d<br/>", total_exec))
  cat(sprintf("<strong>Total emissions:</strong> %.3f g CO2e<br/>", total_emissions_kg * 1000))
  cat(sprintf("<strong>Total energy:</strong> %.6f kWh<br/>", total_energy_kwh))
  cat(sprintf("<strong>Tracked compute time:</strong> %.2f minutes<br/>", total_hours * 60))
  cat(sprintf("<strong>Average per module execution:</strong> %.4f g CO2e<br/><br/>", mean_module_emissions_g))
}
```

For native dashboard UI (similiar to CodeCarbon `dashboard.png`), run:

```bash
carbonboard --filepath=logs/emissions/codecarbon_emissions.csv
```

CodeCarbon tracking during local module computations:

```bash
python3 -m pip install codecarbon
Rscript scripts/run_modules.R --track-emissions
```

CodeCarbon dashboard (optional) upload:

```bash
CODECARBON_SAVE_TO_API=1 CODECARBON_EXPERIMENT_ID=<experiment-id> Rscript scripts/run_modules.R --track-emissions
```

## Run Summary

```{r}
#| echo: false
if (has_data) {
  view_runs <- runs[, c(
    "run_id", "start_time_utc", "end_time_utc",
    "total_duration_seconds", "total_energy_kwh", "total_emissions_kg",
    "avg_emissions_rate_kg_per_hour"
  )]
  view_runs$start_time_utc <- format(view_runs$start_time_utc, "%Y-%m-%d %H:%M:%S UTC")
  view_runs$end_time_utc <- format(view_runs$end_time_utc, "%Y-%m-%d %H:%M:%S UTC")
  view_runs$total_duration_seconds <- round(view_runs$total_duration_seconds, 2)
  view_runs$total_energy_kwh <- round(view_runs$total_energy_kwh, 6)
  view_runs$total_emissions_g <- round(view_runs$total_emissions_kg * 1000, 4)
  view_runs$avg_emissions_rate_g_per_hour <- round(view_runs$avg_emissions_rate_kg_per_hour * 1000, 4)
  view_runs <- view_runs[, c(
    "run_id", "start_time_utc",
    "total_duration_seconds", "total_energy_kwh",
    "total_emissions_g", "avg_emissions_rate_g_per_hour"
  )]
  names(view_runs) <- c(
    "Run ID", "Start",
    "s", "kWh",
    "g CO2e", "g CO2e/hr"
  )
  knitr::kable(
    view_runs,
    format = "pipe",
    align = rep("c", ncol(view_runs)),
    row.names = FALSE,
    escape = FALSE
  )
}
```

Notation:

- `s`: total run duration in seconds.
- `kWh`: total energy consumed in kilowatt-hours.
- `g CO2e`: total emissions in grams of CO2-equivalent.
- `g CO2e/hr`: avg emissions rate for run (g CO2e per hour).

## Modules Summary

```{r}
#| echo: false
if (has_data) {
  view <- modules[, c(
    "module_label", "page_href",
    "avg_duration_seconds", "total_duration_seconds",
    "mean_emissions_kg", "median_emissions_kg", "total_emissions_kg",
    "avg_energy_kwh", "total_energy_kwh",
    "emissions_share_pct", "emissions_rate_kg_per_hour"
  )]
  view$Module <- sprintf("<a href='%s'>%s</a>", view$page_href, view$module_label)
  view$`m̄` <- round(view$avg_duration_seconds / 60, 2)
  view$`Σm` <- round(view$total_duration_seconds / 60, 2)
  view$`ḡ` <- round(view$mean_emissions_kg * 1000, 4)
  view$`g̃` <- round(view$median_emissions_kg * 1000, 4)
  view$`Σg` <- round(view$total_emissions_kg * 1000, 4)
  view$`W̄h` <- round(view$avg_energy_kwh * 1000, 3)
  view$`ΣWh` <- round(view$total_energy_kwh * 1000, 3)
  view$`%` <- round(view$emissions_share_pct, 2)
  view$`g CO2e/hr` <- round(view$emissions_rate_kg_per_hour * 1000, 4)
  view_out <- view[, c(
    "Module",
    "m̄", "Σm",
    "ḡ", "g̃", "Σg",
    "W̄h", "ΣWh",
    "%", "g CO2e/hr"
  )]
  knitr::kable(
    view_out,
    format = "pipe",
    align = rep("c", ncol(view_out)),
    row.names = FALSE,
    escape = FALSE
  )
}
```

Notation:

- `m̄`: average duration per module execution (minutes).
- `Σm`: cumulative duration across executions (minutes).
- `ḡ`: arithmetic mean emissions per execution (grams CO2e).
- `g̃`: median emissions per execution (grams CO2e).
- `Σg`: cumulative emissions across executions (grams CO2e).
- `W̄h`: average energy per execution (watt-hours).
- `ΣWh`: cumulative energy across executions (watt-hours).
- `%`: module share of total tracked emissions (percentage).
- `g CO2e/hr`: emissions intensity in grams CO2e per hour.

## Reduction Recommendations

```{r}
#| echo: false
if (has_data && nrow(recommendations) > 0) {
  names(recommendations) <- c("Priority", "Recommendation", "Rationale")
  knitr::kable(recommendations, row.names = FALSE)
}
```
