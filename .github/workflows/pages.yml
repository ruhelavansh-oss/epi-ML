name: Deploy Quarto Site

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup R
        id: setup_r
        uses: r-lib/actions/setup-r@v2

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Configure R user library
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/.github/R-lib"
          echo "R_LIBS_USER=${GITHUB_WORKSPACE}/.github/R-lib" >> "${GITHUB_ENV}"

      - name: Capture R version
        run: echo "R_VERSION=$(Rscript -e 'cat(as.character(getRversion()))')" >> "${GITHUB_ENV}"

      - name: Cache R packages
        uses: actions/cache@v4
        with:
          path: ${{ env.R_LIBS_USER }}
          key: ${{ runner.os }}-r-${{ env.R_VERSION }}-deps-v2-${{ hashFiles('scripts/install_deps.R') }}

      - name: Setup Quarto (primary)
        id: setup_quarto
        continue-on-error: true
        uses: quarto-dev/quarto-actions/setup@v2

      - name: Setup Quarto (fallback with retry)
        if: steps.setup_quarto.outcome != 'success'
        run: |
          set -euo pipefail
          arch="$(dpkg --print-architecture)"
          case "$arch" in
            amd64) pkg_arch="amd64" ;;
            arm64) pkg_arch="arm64" ;;
            *)
              echo "Unsupported architecture for Quarto fallback install: ${arch}"
              exit 1
              ;;
          esac
          url="https://quarto.org/download/latest/quarto-linux-${pkg_arch}.deb"
          for attempt in 1 2 3; do
            echo "Fallback Quarto install attempt ${attempt}: ${url}"
            if curl -fsSL -o quarto.deb "${url}"; then
              if ! sudo dpkg -i quarto.deb; then
                sudo apt-get update
                sudo apt-get install -f -y
                sudo dpkg -i quarto.deb
              fi
              quarto --version
              exit 0
            fi
            sleep $((attempt * 10))
          done
          echo "Failed to install Quarto via fallback after retries."
          exit 1

      - name: Install system libraries for R packages
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            libcurl4-openssl-dev \
            libssl-dev \
            libxml2-dev \
            libglpk-dev \
            libfontconfig1-dev \
            libfreetype6-dev \
            libharfbuzz-dev \
            libfribidi-dev \
            libpng-dev \
            libjpeg-dev \
            libtiff5-dev \
            libcairo2-dev

      - name: Install R dependencies
        run: |
          CODENAME="$(. /etc/os-release && echo "${VERSION_CODENAME}")"
          if [ -z "${CODENAME}" ]; then CODENAME="jammy"; fi
          export RSPM="https://packagemanager.posit.co/cran/__linux__/${CODENAME}/latest"
          export NCPUS=4
          echo "Using RSPM=${RSPM}"
          Rscript scripts/install_deps.R --full

      - name: Install CodeCarbon
        run: python3 -m pip install --upgrade pip codecarbon

      - name: Security scan
        run: Rscript scripts/security_scan.R

      - name: Clean Quarto freeze cache
        run: rm -rf _freeze .quarto/_freeze

      - name: Seed emissions history from previous deployment
        run: |
          if python3 scripts/seed_emissions_log_from_public.py \
            --source-url "https://ruhelavansh-oss.github.io/epi-ML/data/public/outputs/emissions/emissions_module_events.csv" \
            --require-data \
            --log-path logs/emissions/module_emissions_log.csv; then
            echo "Seeded from live deployed emissions history."
          elif [ -f data/public/outputs/emissions/emissions_module_events.csv ]; then
            python3 scripts/seed_emissions_log_from_public.py \
              --source-file data/public/outputs/emissions/emissions_module_events.csv \
              --log-path logs/emissions/module_emissions_log.csv
            echo "Seeded from repo fallback emissions history."
          else
            echo "No emissions source available for seeding."
          fi

      - name: Resolve private data (decrypt fallback)
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          PRIVATE_DATA_BUNDLE_URL: ${{ secrets.PRIVATE_DATA_BUNDLE_URL }}
          PRIVATE_DATA_BUNDLE_ENC_B64: ${{ secrets.PRIVATE_DATA_BUNDLE_ENC_B64 }}
        run: |
          set -euo pipefail
          echo "PRIVATE_DATA_READY=false" >> "${GITHUB_ENV}"
          echo "DATA_DIR=data/private" >> "${GITHUB_ENV}"
          echo "CI_MODULE_TRACKING_RAN=false" >> "${GITHUB_ENV}"

          if find data/private -maxdepth 1 -type f -name '*.csv' | grep -q .; then
            echo "Private CSV data found in data/private."
            echo "PRIVATE_DATA_READY=true" >> "${GITHUB_ENV}"
            exit 0
          fi

          ENC_PATH="data/private/encrypted/data_bundle.tar.gz.enc"
          if [[ ! -f "${ENC_PATH}" ]] && [[ -n "${PRIVATE_DATA_BUNDLE_URL}" ]]; then
            mkdir -p "$(dirname "${ENC_PATH}")"
            curl -fsSL "${PRIVATE_DATA_BUNDLE_URL}" -o "${ENC_PATH}"
            echo "Downloaded encrypted bundle from PRIVATE_DATA_BUNDLE_URL."
          fi

          if [[ ! -f "${ENC_PATH}" ]] && [[ -n "${PRIVATE_DATA_BUNDLE_ENC_B64}" ]]; then
            mkdir -p "$(dirname "${ENC_PATH}")"
            printf '%s' "${PRIVATE_DATA_BUNDLE_ENC_B64}" | base64 --decode > "${ENC_PATH}"
            echo "Wrote encrypted bundle from PRIVATE_DATA_BUNDLE_ENC_B64 secret."
          fi

          if [[ -f "${ENC_PATH}" ]] && [[ -n "${SECRET_KEY}" ]]; then
            chmod +x scripts/unlock_data_local.sh
            PROJECT_ROOT="${PWD}" bash scripts/unlock_data_local.sh
            if find data/private/runtime -type f -name '*.csv' | grep -q .; then
              echo "Private CSV data restored to data/private/runtime."
              echo "PRIVATE_DATA_READY=true" >> "${GITHUB_ENV}"
              echo "DATA_DIR=data/private/runtime" >> "${GITHUB_ENV}"
            else
              echo "Decrypt attempted but no CSV files were restored."
            fi
          else
            echo "Encrypted bundle or SECRET_KEY missing; skipping decrypt fallback."
          fi

      - name: Run modules with emissions tracking (if private data resolved)
        if: env.PRIVATE_DATA_READY == 'true'
        env:
          EPI_ML_EMISSIONS_RUN_ID: gh-${{ github.run_id }}-${{ github.run_attempt }}
          DATA_DIR: ${{ env.DATA_DIR }}
        run: |
          Rscript scripts/run_modules.R \
            --track-emissions \
            --python-bin=python3 \
            --emissions-measure-power-secs=1 \
            --emissions-project-name=epi-ML-deploy
          echo "CI_MODULE_TRACKING_RAN=true" >> "${GITHUB_ENV}"

      - name: Explain module tracking skip
        if: env.PRIVATE_DATA_READY != 'true'
        run: echo "Skipping module orchestration emissions in CI because private data is unavailable."

      - name: Track publish artifacts emissions
        env:
          EPI_ML_EMISSIONS_RUN_ID: gh-${{ github.run_id }}-${{ github.run_attempt }}
        run: |
          python3 scripts/track_emissions.py \
            --module ci_publish_public_artifacts \
            --run-id "${EPI_ML_EMISSIONS_RUN_ID}" \
            --log-dir logs/emissions \
            --project-name epi-ML-deploy \
            --measure-power-secs 1 \
            -- Rscript scripts/publish_public_artifacts.R

      - name: Track site render emissions
        env:
          EPI_ML_EMISSIONS_RUN_ID: gh-${{ github.run_id }}-${{ github.run_attempt }}
        run: |
          python3 scripts/track_emissions.py \
            --module ci_quarto_render \
            --run-id "${EPI_ML_EMISSIONS_RUN_ID}" \
            --log-dir logs/emissions \
            --project-name epi-ML-deploy \
            --measure-power-secs 1 \
            -- quarto render --cache-refresh

      - name: Refresh emissions dashboard artifacts
        run: Rscript scripts/publish_public_artifacts.R

      - name: Verify emissions source coverage
        env:
          PRIVATE_DATA_READY: ${{ env.PRIVATE_DATA_READY }}
          CI_MODULE_TRACKING_RAN: ${{ env.CI_MODULE_TRACKING_RAN }}
        run: |
          python3 - <<'PY'
          import csv
          import os
          import sys
          from collections import Counter

          run_path = "data/public/outputs/emissions/emissions_run_summary.csv"
          if not os.path.exists(run_path):
              print(f"[emissions-check] missing file: {run_path}")
              sys.exit(0)

          with open(run_path, newline="", encoding="utf-8") as handle:
              rows = list(csv.DictReader(handle))

          run_count = len(rows)
          source_counts = Counter((r.get("run_source") or "").strip().lower() for r in rows)
          normalized = Counter()
          for key, val in source_counts.items():
              if key in ("local", "cloud"):
                  normalized[key] += val
              else:
                  normalized["unknown"] += val
          latest_ids = [r.get("run_id", "") for r in rows[-5:]]

          print(f"[emissions-check] run_count={run_count}")
          print(f"[emissions-check] run_source_counts={dict(normalized)}")
          print(f"[emissions-check] latest_run_ids={latest_ids}")

          private_ready = os.getenv("PRIVATE_DATA_READY", "").lower() == "true"
          module_tracking_ran = os.getenv("CI_MODULE_TRACKING_RAN", "").lower() == "true"
          cloud_count = normalized.get("cloud", 0)

          if private_ready and module_tracking_ran and cloud_count == 0:
              print(
                  "[emissions-check] ERROR: module tracking ran in CI but no cloud runs were published."
              )
              sys.exit(1)
          PY

      - name: Validate Power Design page
        run: Rscript scripts/check_power_design_render.R

      - name: Post-render security scan
        run: Rscript scripts/security_scan.R --include-rendered

      - name: Configure Pages
        uses: actions/configure-pages@v5
        with:
          enablement: true

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: _site

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
